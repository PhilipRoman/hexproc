= hexproc(1)
Philip Roman
include::../VERSION[]
:doctype: manpage

== Name

hexproc - hexadecimal preprocessor for building binary files or hexdumps

== Synopsis

`*hexproc* [_OPTION..._] [_FILE_]`

== Options

*-v*::
	Prints the program version and exits

*-h*::
	Prints a brief help message and exits

*-b*::
	Outputs binary data instead of hexadecimal

*-B*::
	Forces writing binary data even if output is a TTY

*-d*::
	Enter debug mode

== Description

Hexproc is a tool for building hex files. The input file
(or `stdin`, if no file given) is processed and then
written to `stdout`.

Hexproc is meant to be used as part of a pipeline and
therefore does not implement many features which are
provided by other processing tools.

It is recommended to use a text preprocessor (such as
`cpp` or `m4`) before feeding the input to `hexproc` as
`hexproc` does not provide macros or file inclusion.

== Syntax

Hexproc input consists of the following tokens:

*strings*::
	Quoted ASCII text is converted to bytes and replaced
	with hexadecimal octets

*octets*::
	Two hexadecimal digits will appear on the output as-is

*comments*::
	End-of-line comments are created using `#` or `//`; Note that
	comments created with `#` can be used as line markers, similar
	to how the C preprocessor uses them.

*expressions*::
	Expressions are not standalone constructs, they are used
	in forming *variables*. Expressions can be described using
	the following grammar (operator precedence works just like in C):

	exp ::= VariableName
	exp ::= Decimal
	exp ::= Hexadecimal
	exp ::= exp + exp
	exp ::= exp - exp
	exp ::= exp * exp
	exp ::= exp / exp
	exp ::= exp ^ exp
	exp ::= exp & exp
	exp ::= exp | exp
	exp ::= exp ~ exp

*labels*::
	The syntax `LABEL_NAME:` will assign the current byte offset
	to the specified name. Labels may freely appear between tokens.

*lazy assignment*::
	The syntax `VAR_NAME = EXPRESSION` will map the variable name to the
	given expression without evaluating it. Whenever the name is
	referenced, the expression will be evaluated. The expression must
	not be recursive. If you want to add more tokens after an assignment,
	terminate the expression with `;`.

*immediate assignment*::
	The syntax `VAR_NAME := EXPRESSION` will evaluate the expression and
	assign the result to the variable. The expression may reference the
	variable it's being assigned to. If you want to add more tokens after
	an assignment, terminate the expression with `;`.

*formatters*::
	An expression in form of `[TYPE]EXPRESSION` or `[TYPE](EXPRESSION)`
	is called a _formatter_ (the first form is a shorthand for when the
	expression is a number or a variable name). `TYPE` may be an integer
	denoting the number of bytes to use or a _type name_, such as "int64"
	or "float", which is replaced with the size of that type (but may also
	have influence on the representation of the value). See section
	_Type Names_ for more information. The expression is evaluated lazily.

Leading and trailing whitespace is ignored.

Hexproc maps lines one-to-one so that line numbers
are preserved.

== Type Names
The following identifiers may be used as type names:

* int64, int32, int16, int8 - fixed size types
* long, int, short, byte - synonymous with fixed size types
* ieee754_single, ieee754_double - IEEE 754 single and double precision floating point types
* float, double - synonymous with above floating point types

== Debugger
Hexproc comes with a built-in debugger, which you can activate using the `-d` option
or writing `_Debug` in the source code. The debugger supports the following commands:

*break* _NUMBER_, *brk* _NUMBER_::
	Ccreates a breakpoint on given line number. When execution reaches a
	line with a breakpoint, it will enter the debugger before evaluating the line

*run*, *resume*:: Exits the debugger and resumes execution.

*vars*:: Displays the current state of all variables

*help*:: Shows help on how to use the debugger

== See Also
xxd(1), cpp(1)
